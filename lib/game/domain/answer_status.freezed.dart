// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'answer_status.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AnswerStatus {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() correct,
    required TResult Function() wrongPlace,
    required TResult Function() wrong,
    required TResult Function() blank,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? correct,
    TResult Function()? wrongPlace,
    TResult Function()? wrong,
    TResult Function()? blank,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? correct,
    TResult Function()? wrongPlace,
    TResult Function()? wrong,
    TResult Function()? blank,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Correct value) correct,
    required TResult Function(_WrongPlace value) wrongPlace,
    required TResult Function(_Wrong value) wrong,
    required TResult Function(_Blank value) blank,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Correct value)? correct,
    TResult Function(_WrongPlace value)? wrongPlace,
    TResult Function(_Wrong value)? wrong,
    TResult Function(_Blank value)? blank,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Correct value)? correct,
    TResult Function(_WrongPlace value)? wrongPlace,
    TResult Function(_Wrong value)? wrong,
    TResult Function(_Blank value)? blank,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnswerStatusCopyWith<$Res> {
  factory $AnswerStatusCopyWith(
          AnswerStatus value, $Res Function(AnswerStatus) then) =
      _$AnswerStatusCopyWithImpl<$Res>;
}

/// @nodoc
class _$AnswerStatusCopyWithImpl<$Res> implements $AnswerStatusCopyWith<$Res> {
  _$AnswerStatusCopyWithImpl(this._value, this._then);

  final AnswerStatus _value;
  // ignore: unused_field
  final $Res Function(AnswerStatus) _then;
}

/// @nodoc
abstract class _$$_CorrectCopyWith<$Res> {
  factory _$$_CorrectCopyWith(
          _$_Correct value, $Res Function(_$_Correct) then) =
      __$$_CorrectCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CorrectCopyWithImpl<$Res> extends _$AnswerStatusCopyWithImpl<$Res>
    implements _$$_CorrectCopyWith<$Res> {
  __$$_CorrectCopyWithImpl(_$_Correct _value, $Res Function(_$_Correct) _then)
      : super(_value, (v) => _then(v as _$_Correct));

  @override
  _$_Correct get _value => super._value as _$_Correct;
}

/// @nodoc

class _$_Correct extends _Correct {
  const _$_Correct() : super._();

  @override
  String toString() {
    return 'AnswerStatus.correct()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Correct);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() correct,
    required TResult Function() wrongPlace,
    required TResult Function() wrong,
    required TResult Function() blank,
  }) {
    return correct();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? correct,
    TResult Function()? wrongPlace,
    TResult Function()? wrong,
    TResult Function()? blank,
  }) {
    return correct?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? correct,
    TResult Function()? wrongPlace,
    TResult Function()? wrong,
    TResult Function()? blank,
    required TResult orElse(),
  }) {
    if (correct != null) {
      return correct();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Correct value) correct,
    required TResult Function(_WrongPlace value) wrongPlace,
    required TResult Function(_Wrong value) wrong,
    required TResult Function(_Blank value) blank,
  }) {
    return correct(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Correct value)? correct,
    TResult Function(_WrongPlace value)? wrongPlace,
    TResult Function(_Wrong value)? wrong,
    TResult Function(_Blank value)? blank,
  }) {
    return correct?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Correct value)? correct,
    TResult Function(_WrongPlace value)? wrongPlace,
    TResult Function(_Wrong value)? wrong,
    TResult Function(_Blank value)? blank,
    required TResult orElse(),
  }) {
    if (correct != null) {
      return correct(this);
    }
    return orElse();
  }
}

abstract class _Correct extends AnswerStatus {
  const factory _Correct() = _$_Correct;
  const _Correct._() : super._();
}

/// @nodoc
abstract class _$$_WrongPlaceCopyWith<$Res> {
  factory _$$_WrongPlaceCopyWith(
          _$_WrongPlace value, $Res Function(_$_WrongPlace) then) =
      __$$_WrongPlaceCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_WrongPlaceCopyWithImpl<$Res> extends _$AnswerStatusCopyWithImpl<$Res>
    implements _$$_WrongPlaceCopyWith<$Res> {
  __$$_WrongPlaceCopyWithImpl(
      _$_WrongPlace _value, $Res Function(_$_WrongPlace) _then)
      : super(_value, (v) => _then(v as _$_WrongPlace));

  @override
  _$_WrongPlace get _value => super._value as _$_WrongPlace;
}

/// @nodoc

class _$_WrongPlace extends _WrongPlace {
  const _$_WrongPlace() : super._();

  @override
  String toString() {
    return 'AnswerStatus.wrongPlace()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_WrongPlace);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() correct,
    required TResult Function() wrongPlace,
    required TResult Function() wrong,
    required TResult Function() blank,
  }) {
    return wrongPlace();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? correct,
    TResult Function()? wrongPlace,
    TResult Function()? wrong,
    TResult Function()? blank,
  }) {
    return wrongPlace?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? correct,
    TResult Function()? wrongPlace,
    TResult Function()? wrong,
    TResult Function()? blank,
    required TResult orElse(),
  }) {
    if (wrongPlace != null) {
      return wrongPlace();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Correct value) correct,
    required TResult Function(_WrongPlace value) wrongPlace,
    required TResult Function(_Wrong value) wrong,
    required TResult Function(_Blank value) blank,
  }) {
    return wrongPlace(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Correct value)? correct,
    TResult Function(_WrongPlace value)? wrongPlace,
    TResult Function(_Wrong value)? wrong,
    TResult Function(_Blank value)? blank,
  }) {
    return wrongPlace?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Correct value)? correct,
    TResult Function(_WrongPlace value)? wrongPlace,
    TResult Function(_Wrong value)? wrong,
    TResult Function(_Blank value)? blank,
    required TResult orElse(),
  }) {
    if (wrongPlace != null) {
      return wrongPlace(this);
    }
    return orElse();
  }
}

abstract class _WrongPlace extends AnswerStatus {
  const factory _WrongPlace() = _$_WrongPlace;
  const _WrongPlace._() : super._();
}

/// @nodoc
abstract class _$$_WrongCopyWith<$Res> {
  factory _$$_WrongCopyWith(_$_Wrong value, $Res Function(_$_Wrong) then) =
      __$$_WrongCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_WrongCopyWithImpl<$Res> extends _$AnswerStatusCopyWithImpl<$Res>
    implements _$$_WrongCopyWith<$Res> {
  __$$_WrongCopyWithImpl(_$_Wrong _value, $Res Function(_$_Wrong) _then)
      : super(_value, (v) => _then(v as _$_Wrong));

  @override
  _$_Wrong get _value => super._value as _$_Wrong;
}

/// @nodoc

class _$_Wrong extends _Wrong {
  const _$_Wrong() : super._();

  @override
  String toString() {
    return 'AnswerStatus.wrong()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Wrong);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() correct,
    required TResult Function() wrongPlace,
    required TResult Function() wrong,
    required TResult Function() blank,
  }) {
    return wrong();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? correct,
    TResult Function()? wrongPlace,
    TResult Function()? wrong,
    TResult Function()? blank,
  }) {
    return wrong?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? correct,
    TResult Function()? wrongPlace,
    TResult Function()? wrong,
    TResult Function()? blank,
    required TResult orElse(),
  }) {
    if (wrong != null) {
      return wrong();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Correct value) correct,
    required TResult Function(_WrongPlace value) wrongPlace,
    required TResult Function(_Wrong value) wrong,
    required TResult Function(_Blank value) blank,
  }) {
    return wrong(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Correct value)? correct,
    TResult Function(_WrongPlace value)? wrongPlace,
    TResult Function(_Wrong value)? wrong,
    TResult Function(_Blank value)? blank,
  }) {
    return wrong?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Correct value)? correct,
    TResult Function(_WrongPlace value)? wrongPlace,
    TResult Function(_Wrong value)? wrong,
    TResult Function(_Blank value)? blank,
    required TResult orElse(),
  }) {
    if (wrong != null) {
      return wrong(this);
    }
    return orElse();
  }
}

abstract class _Wrong extends AnswerStatus {
  const factory _Wrong() = _$_Wrong;
  const _Wrong._() : super._();
}

/// @nodoc
abstract class _$$_BlankCopyWith<$Res> {
  factory _$$_BlankCopyWith(_$_Blank value, $Res Function(_$_Blank) then) =
      __$$_BlankCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_BlankCopyWithImpl<$Res> extends _$AnswerStatusCopyWithImpl<$Res>
    implements _$$_BlankCopyWith<$Res> {
  __$$_BlankCopyWithImpl(_$_Blank _value, $Res Function(_$_Blank) _then)
      : super(_value, (v) => _then(v as _$_Blank));

  @override
  _$_Blank get _value => super._value as _$_Blank;
}

/// @nodoc

class _$_Blank extends _Blank {
  const _$_Blank() : super._();

  @override
  String toString() {
    return 'AnswerStatus.blank()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Blank);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() correct,
    required TResult Function() wrongPlace,
    required TResult Function() wrong,
    required TResult Function() blank,
  }) {
    return blank();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? correct,
    TResult Function()? wrongPlace,
    TResult Function()? wrong,
    TResult Function()? blank,
  }) {
    return blank?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? correct,
    TResult Function()? wrongPlace,
    TResult Function()? wrong,
    TResult Function()? blank,
    required TResult orElse(),
  }) {
    if (blank != null) {
      return blank();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Correct value) correct,
    required TResult Function(_WrongPlace value) wrongPlace,
    required TResult Function(_Wrong value) wrong,
    required TResult Function(_Blank value) blank,
  }) {
    return blank(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Correct value)? correct,
    TResult Function(_WrongPlace value)? wrongPlace,
    TResult Function(_Wrong value)? wrong,
    TResult Function(_Blank value)? blank,
  }) {
    return blank?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Correct value)? correct,
    TResult Function(_WrongPlace value)? wrongPlace,
    TResult Function(_Wrong value)? wrong,
    TResult Function(_Blank value)? blank,
    required TResult orElse(),
  }) {
    if (blank != null) {
      return blank(this);
    }
    return orElse();
  }
}

abstract class _Blank extends AnswerStatus {
  const factory _Blank() = _$_Blank;
  const _Blank._() : super._();
}
